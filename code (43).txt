--[[
    THE MIST Triggerbot v27 (24) - FINAL EXPLICIT OPPONENTS + Delay Mode Switcher (Compacted)
--]]

--- START OF MODIFIED SCRIPT v27 (24 - Delay Mode Switcher) ---
local P = game:GetService("Players")
local RS = game:GetService("ReplicatedStorage")
local RuS = game:GetService("RunService")
local UIS = game:GetService("UserInputService")
local TS = game:GetService("TweenService")
local GS = game:GetService("GuiService")
local CG = game:GetService("CoreGui")
local Cam = workspace.CurrentCamera
local gameDefFOV = Cam.FieldOfView
local D = game:GetService("Debris")
local SS = game:GetService("SoundService")

local plr = P.LocalPlayer
local char = plr.Character or plr.CharacterAdded:Wait()
local backpack = plr:WaitForChild("Backpack")
local pGui = plr:WaitForChild("PlayerGui")

local autoTargetOn = true; local lastShot = 0;
local CD = 0.5;
local targetFOV = 35;
local delayMode = "Blatant"
local shootDelayMs = (delayMode == "Normal") and 264 or 0
local fovC = nil;
local excludedPlrs = {};
local stealthMode = true
local espOn = false;
local fovChangerOn = false;
local defScriptFOV = 115;
local camFOV = gameDefFOV;

local currTool = nil
local actConn = nil
local currEffCD = 0

local createGUI
local updFOVCircle, updAllExclLblsVis, toggleESP, setSliderOn, setSliderVal, updExclLbl, setupTool, calcEffCD, findTool

local BulletRenderer_mod = nil
local sBR, eBR = pcall(function()
	local modulesFolder = RS:FindFirstChild("Modules")
	if modulesFolder and modulesFolder:FindFirstChild("BulletRenderer") then
		BulletRenderer_mod = require(modulesFolder.BulletRenderer)
	end
end)

local THEME = { Background = Color3.fromRGB(18, 18, 22), BackgroundSlightlyLighter = Color3.fromRGB(24, 24, 28), BackgroundSubtleVariant = Color3.fromRGB(21, 21, 25), Primary = Color3.fromRGB(35, 35, 45), PrimaryLighter = Color3.fromRGB(45, 45, 55), Secondary = Color3.fromRGB(55, 55, 65), Tertiary = Color3.fromRGB(75, 75, 85), Accent = Color3.fromRGB(0, 180, 180), AccentAlt = Color3.fromRGB(0, 140, 140), Text = Color3.fromRGB(235, 235, 245), TextActive = Color3.fromRGB(255, 255, 255), TextDisabled = Color3.fromRGB(110, 110, 120), TextPlayerListNormal = Color3.fromRGB(240, 240, 250), Success = Color3.fromRGB(30, 200, 130), Error = Color3.fromRGB(250, 60, 80), ExcludedIcon = Color3.fromRGB(250, 60, 80), Tooltip = Color3.fromRGB(8, 8, 10), ButtonText = Color3.fromRGB(240, 240, 250), ButtonBackground = Color3.fromRGB(35, 35, 45), ButtonBackgroundHover = Color3.fromRGB(45, 45, 55), ButtonOutline = Color3.fromRGB(75, 75, 85), ButtonOutlineHover = Color3.fromRGB(0, 180, 180), SliderTrack = Color3.fromRGB(55, 55, 65), SliderTrackDisabled = Color3.fromRGB(35, 35, 45), SliderThumbBorder = Color3.fromRGB(18, 18, 22), SliderThumbBorderDisabled = Color3.fromRGB(35, 35, 45), ExcludeLabelBg = Color3.fromRGB(50, 10, 50), ExcludeLabelOutline = Color3.fromRGB(220, 220, 220), Font = Enum.Font.GothamSemibold, FontTitle = Enum.Font.GothamBold, FontIcon = Enum.Font.SourceSansBold, FontRegular = Enum.Font.Gotham, TextSize = 11, SmallTextSize = 9, TitleSize = 12, IconSize = 14, SubtitleSize = 8, DisclaimerSize = 7, CornerRadius = 6, Padding = 6, ElementHeight = 24, SmallElementHeight = 20, SliderHeight = 4, SliderThumbSize = 12, PanelMinWidth = 190, PanelMaxWidth = 285, AnimationSpeed = 0.2, ScaleFactorHover = 1.02, ScaleFactorPress = 0.98, StrokeThickness = 1, ButtonOutlineThickness = 1.5, StrokeTransparency = 0.6, StrokeTransparencyHover = 0.4, RefExcludedColor = Color3.fromRGB(255, 0, 0), RefFOVCircleColor = Color3.fromRGB(128, 0, 128), TextColorFadeDuration = 0.25 }
local TxtColorTweenInfo = TweenInfo.new(THEME.TextColorFadeDuration, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut); local DimTweenInfo = TweenInfo.new(THEME.AnimationSpeed, Enum.EasingStyle.Sine, Enum.EasingDirection.Out);
local SwitchAnimInfo = TweenInfo.new(0.25, Enum.EasingStyle.Cubic, Enum.EasingDirection.Out)

local Storage = Instance.new("Folder", CG) Storage.Name = "TheMist_Storage_DelaySwitcher_V24"
local function cleanupOldStorage() for _, v in ipairs(CG:GetChildren()) do if v:IsA("Folder") and v.Name:match("Storage") and v ~= Storage then v:Destroy() end end end; cleanupOldStorage()

local GuiElems = {}
local TooltipLbl = nil
local mainFrm = nil
local panelVis = false

function calcEffCD(toolInst)
    if not toolInst or not toolInst:IsA("Tool") then return CD end
    local gameCD = toolInst:GetAttribute("Cooldown")
    return (type(gameCD) == "number" and gameCD > 0) and gameCD or CD
end
function createDrawingCircle() if not pcall(function() local _ = Drawing.new end) then return nil end local circle = Drawing.new("Circle"); circle.Thickness = 2; circle.Color = THEME.RefFOVCircleColor; circle.Transparency = 0.5; circle.Filled = false; circle.NumSides = 64; circle.Visible = false; return circle end
function updFOVCircle() if not fovC then return end; local shouldBeVis = autoTargetOn and (not stealthMode or panelVis); fovC.Visible = shouldBeVis; if not shouldBeVis then return end; local scrSize = Cam.ViewportSize; if not scrSize or scrSize.X == 0 or scrSize.Y == 0 then fovC.Visible = false; return end; fovC.Position = scrSize / 2; local fovRad = math.rad(targetFOV / 2); local camFovRad = math.rad(Cam.FieldOfView / 2); if fovRad <= 0 or camFovRad <= 0 or math.tan(camFovRad) == 0 then fovC.Visible = false; return end; local radius = (scrSize.Y / 2) * math.tan(fovRad) / math.tan(camFovRad); fovC.Radius = math.max(0, radius); end
function updExclLbl(targetPlr) local c = targetPlr.Character; if not c or not c:FindFirstChild("Head") then return end; local head = c.Head; local billboard = head:FindFirstChild("ExcludeLabel"); local isExcl = excludedPlrs[targetPlr]; if isExcl then if not billboard then billboard = Instance.new("BillboardGui", head); billboard.Name = "ExcludeLabel"; billboard.Size = UDim2.new(0, 85, 0, 22); billboard.StudsOffset = Vector3.new(0, 2.4, 0); billboard.AlwaysOnTop = true; billboard.LightInfluence = 0; billboard.ClipsDescendants = true; local txtLbl = Instance.new("TextLabel", billboard); txtLbl.Size = UDim2.fromScale(1, 1); txtLbl.BackgroundColor3 = THEME.ExcludeLabelBg; txtLbl.BackgroundTransparency = 0.2; txtLbl.Font = Enum.Font.GothamSemibold; txtLbl.Text = "EXCLUDED"; txtLbl.TextColor3 = THEME.RefExcludedColor; txtLbl.TextSize = 11; txtLbl.TextScaled = false; txtLbl.TextXAlignment = Enum.TextXAlignment.Center; txtLbl.TextYAlignment = Enum.TextYAlignment.Center; Instance.new("UICorner", txtLbl).CornerRadius = UDim.new(0, 3); local stroke = Instance.new("UIStroke", txtLbl); stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border; stroke.Color = THEME.ExcludeLabelOutline; stroke.Thickness = 1; stroke.Transparency = 0.3; end; billboard.Enabled = (not stealthMode or panelVis); else if billboard then billboard:Destroy() end end end
function updAllExclLblsVis() local desiredVis = (not stealthMode or panelVis); for p, _ in pairs(excludedPlrs) do if p and p.Character and p.Character:FindFirstChild("Head") then local billboard = p.Character.Head:FindFirstChild("ExcludeLabel"); if billboard then billboard.Enabled = desiredVis end end end end
function applyHighlight(p) if p == plr then return end; local existing = Storage:FindFirstChild(p.Name); if existing then existing:Destroy() end; local hl = Instance.new("Highlight", Storage); hl.Name = p.Name; hl.FillColor = p.Team and p.Team.TeamColor.Color or Color3.fromRGB(255, 255, 255); hl.FillTransparency = 0.5; hl.OutlineColor = Color3.fromRGB(255, 255, 255); hl.OutlineTransparency = 0; hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop; hl.Enabled = espOn; if p.Character then hl.Adornee = p.Character end; p.CharacterAdded:Connect(function(c) if hl and hl.Parent then hl.Adornee = c end end); p.CharacterRemoving:Connect(function() if hl and hl.Parent then hl.Adornee = nil end end); return hl end
function removeHighlight(p) if p then local existing = Storage:FindFirstChild(p.Name); if existing then existing:Destroy() end end end
function toggleESP(enabled) if stealthMode and enabled then return end; espOn = enabled; if enabled then for _, p_ in pairs(P:GetPlayers()) do if p_ ~= plr then local h = Storage:FindFirstChild(p_.Name); if h then h.Enabled = true else applyHighlight(p_) end end end else for _, hl in pairs(Storage:GetChildren()) do if hl:IsA("Highlight") then hl.Enabled = false end end end; if GuiElems.espBtn then local stateTxt = espOn and "ESP: ON" or "ESP: OFF"; local newTxtColor = espOn and THEME.Success or THEME.Error; GuiElems.espBtn.Text = stateTxt; GuiElems.espBtn:SetAttribute("CurrentTextColor", newTxtColor); TS:Create(GuiElems.espBtn, TxtColorTweenInfo, { TextColor3 = newTxtColor }):Play() end end
function getShootEvent() local remotes = RS:FindFirstChild("Remotes"); return remotes and remotes:FindFirstChild("Shoot") end
function findTool() if char then for _, child in pairs(char:GetChildren()) do if child:IsA("Tool") then return child end end end; if backpack then for _, child in pairs(backpack:GetChildren()) do if child:IsA("Tool") then return child end end end; return nil end
function isVisible(targetC) if not char or not char:FindFirstChild("HumanoidRootPart") then return false end; local startPos = char.HumanoidRootPart.Position; local partsToCheck = {"Head", "LeftHand", "RightHand", "LeftFoot", "RightFoot", "HumanoidRootPart"}; local rayParams = RaycastParams.new(); rayParams.FilterDescendantsInstances = {char, Storage}; rayParams.FilterType = Enum.RaycastFilterType.Blacklist; rayParams.IgnoreWater = true; for _, partName in pairs(partsToCheck) do local targetPart = targetC:FindFirstChild(partName); if targetPart then local targetPos = targetPart.Position; local dir = targetPos - startPos; local dist = dir.Magnitude; if dist < 0.1 then continue end; local rayRes = workspace:Raycast(startPos, dir.Unit * dist, rayParams); if not rayRes or rayRes.Instance:IsDescendantOf(targetC) then return true end end end; return false end
function isWithinFOV(targetPart) if not char or not char:FindFirstChild("HumanoidRootPart") then return false end; local camCF = Cam.CFrame; local targetPos = targetPart.Position; local camPos = camCF.Position; if (targetPos - camPos).Magnitude < 0.1 then return true end; local dirToTarget = (targetPos - camPos).Unit; local camLook = camCF.LookVector; local dot = math.clamp(dirToTarget:Dot(camLook), -1, 1); local angle = math.deg(math.acos(dot)); return angle <= (targetFOV / 2) end

function setupTool(toolInst)
    if actConn then actConn:Disconnect(); actConn = nil end
    if currTool and currTool ~= toolInst and not currTool.Enabled then pcall(function() currTool.Enabled = true end) end
    currTool = toolInst
    if toolInst and toolInst:IsA("Tool") then
        local cdActive = currEffCD > 0 and (tick() - lastShot < currEffCD)
        pcall(function() toolInst.Enabled = not cdActive end)
        actConn = toolInst.Activated:Connect(function()
            lastShot = tick()
            currEffCD = calcEffCD(toolInst)
            if toolInst then pcall(function() toolInst.Enabled = false end) end
        end)
    else
         currEffCD = 0
    end
end

function findEnemy()
    local maxDist = 400; local closestEnemy = nil; local closestDist = maxDist;
    local plrRootPart = char and char:FindFirstChild("HumanoidRootPart")
    if not plrRootPart then return nil end
    local plrRootPos = plrRootPart.Position; local myTeam = plr.Team
    if not myTeam then return nil end
    for _, targetPlr in pairs(P:GetPlayers()) do
        if targetPlr ~= plr and targetPlr.Character and targetPlr.Character:FindFirstChild("HumanoidRootPart") and targetPlr.Character:FindFirstChildOfClass("Humanoid") then
            local targetC = targetPlr.Character; local targetRoot = targetC.HumanoidRootPart;
            local targetHum = targetC:FindFirstChildOfClass("Humanoid"); local targetTeam = targetPlr.Team
            local isOpponent = false
            if targetTeam then
                if myTeam.Name == "Team1" and targetTeam.Name == "Team2" then isOpponent = true
                elseif myTeam.Name == "Team2" and targetTeam.Name == "Team1" then isOpponent = true end
            end
            if targetHum.Health > 0 and not excludedPlrs[targetPlr] and isOpponent then
                local dist = (plrRootPos - targetRoot.Position).Magnitude;
                if dist < closestDist then
                    if isVisible(targetC) and isWithinFOV(targetRoot) then
                        closestDist = dist; closestEnemy = targetPlr;
                    end
                end
            end
        end
    end
    return closestEnemy
end

function shoot()
    if not autoTargetOn then return end;
    if not char or not char.Parent then return end
    if not char:FindFirstChild("HumanoidRootPart") then return end;

    local tool = currTool
    if not tool or tool.Parent ~= char then
        tool = findTool()
        if tool and tool.Parent == char then setupTool(tool) else return end
    end

    local shootEvent = getShootEvent(); if not shootEvent then return end;
    local effCD = calcEffCD(tool); local currTime = tick();

    if currTime - lastShot < effCD then return end

    local targetEnemy = findEnemy();
    if targetEnemy and targetEnemy.Character and targetEnemy.Character:FindFirstChild("HumanoidRootPart") then
        lastShot = currTime
        currEffCD = effCD

        local toolNow = tool
        local targetPartNow = targetEnemy.Character.HumanoidRootPart;
        local targetPosNow = targetPartNow.Position
        local fireSndNow = tool:FindFirstChild("Fire");
        local bulletTypeNow = tool:GetAttribute("BulletType");
        local startPosNow;
        local muzzleAttach = tool:FindFirstChild("Muzzle", true);
        if muzzleAttach and muzzleAttach:IsA("Attachment") then startPosNow = muzzleAttach.WorldPosition
        else local handle = tool:FindFirstChild("Handle"); startPosNow = (handle and handle:IsA("BasePart") and handle.Position) or char.HumanoidRootPart.Position end;

        task.spawn(function()
            if shootDelayMs > 0 then
                task.wait(shootDelayMs / 1000)
            end
            if not toolNow or toolNow.Parent ~= char then return end
            if not char or not char.Parent then return end
            if not targetEnemy or not targetEnemy.Parent or not targetEnemy.Character or not targetEnemy.Character.Parent then return end
            local targetHum = targetEnemy.Character:FindFirstChildOfClass("Humanoid")
            local targetRootPart = targetEnemy.Character:FindFirstChild("HumanoidRootPart")
            if not targetHum or not targetRootPart or targetHum.Health <= 0 or excludedPlrs[targetEnemy] then return end

            local currTargetPos = targetRootPart.Position
            local currTargetPart = targetRootPart

            local sFire, eFire = pcall(function()
                shootEvent:FireServer(char.HumanoidRootPart.Position, currTargetPos, currTargetPart, currTargetPos)
            end)

            if sFire then
                if fireSndNow and fireSndNow:IsA("Sound") then pcall(function() fireSndNow:Play() end) end;
                if BulletRenderer_mod and muzzleAttach then pcall(BulletRenderer_mod, startPosNow, currTargetPos, bulletTypeNow) end;
                pcall(function() toolNow:Activate() end);
                task.wait()
                if toolNow and toolNow.Parent == char then
                    pcall(function() toolNow.Enabled = false end)
                end
            end
        end)
    end
end

function getTTipLabel(parent) if TooltipLbl and TooltipLbl.Parent then return TooltipLbl end TooltipLbl = Instance.new("Frame", parent); TooltipLbl.Name = "TooltipFrame"; TooltipLbl.Size = UDim2.new(0, 100, 0, 25); TooltipLbl.BackgroundColor3 = THEME.Tooltip; TooltipLbl.BackgroundTransparency = 0.05; TooltipLbl.BorderSizePixel = 0; TooltipLbl.Position = UDim2.new(0, 0, 0, 0); TooltipLbl.ZIndex = 100; TooltipLbl.Visible = false; TooltipLbl.ClipsDescendants = true; Instance.new("UICorner", TooltipLbl).CornerRadius = UDim.new(0, 3); local pad = Instance.new("UIPadding", TooltipLbl); pad.PaddingLeft = UDim.new(0, 5); pad.PaddingRight = UDim.new(0, 5); pad.PaddingTop = UDim.new(0, 3); pad.PaddingBottom = UDim.new(0, 3); local txtLbl = Instance.new("TextLabel", TooltipLbl); txtLbl.Name = "TooltipText"; txtLbl.Size = UDim2.new(1, 0, 1, 0); txtLbl.BackgroundTransparency = 1; txtLbl.TextColor3 = THEME.TextDisabled; txtLbl.Font = THEME.Font; txtLbl.TextSize = THEME.SmallTextSize; txtLbl.TextXAlignment = Enum.TextXAlignment.Center; txtLbl.TextYAlignment = Enum.TextYAlignment.Center; txtLbl.Text = "Tooltip"; txtLbl.ZIndex = 101; txtLbl.RichText = true; Instance.new("UITextSizeConstraint", txtLbl).MaxTextSize = THEME.SmallTextSize; local function updSize() task.wait(); if not txtLbl or not txtLbl.Parent then return end; TooltipLbl.Size = UDim2.new(0, txtLbl.TextBounds.X + 10, 0, txtLbl.TextBounds.Y + 6) end; txtLbl:GetPropertyChangedSignal("Text"):Connect(updSize); updSize(); return TooltipLbl end
function showTooltip(guiObj, text) if not TooltipLbl or not TooltipLbl.Parent then return end local txtLbl = TooltipLbl:FindFirstChild("TooltipText"); if not txtLbl then return end; txtLbl.Text = text; local mousePos = UIS:GetMouseLocation(); local guiInset = GS:GetGuiInset(); local offX, offY = 15, 10; TooltipLbl.Position = UDim2.new(0, mousePos.X + offX, 0, mousePos.Y - guiInset.Y + offY); task.wait(); local vpSize = Cam.ViewportSize; local absSize = TooltipLbl.AbsoluteSize; local currPosX, currPosY = TooltipLbl.Position.X.Offset, TooltipLbl.Position.Y.Offset; if currPosX + absSize.X > vpSize.X then currPosX = mousePos.X - absSize.X - offX end; if currPosY + absSize.Y > vpSize.Y - guiInset.Y then currPosY = mousePos.Y - absSize.Y - offY - guiInset.Y end; TooltipLbl.Position = UDim2.new(0, currPosX, 0, currPosY); TooltipLbl.Visible = true end
function hideTooltip() if TooltipLbl then TooltipLbl.Visible = false end end
function mkBtn(parent, initText, initTxtColor, pos, size, ttipText) local btn = Instance.new("TextButton", parent); btn.Size = size; btn.Position = pos; btn.BackgroundColor3 = THEME.ButtonBackground; btn.Font = THEME.Font; btn.Text = initText; btn.TextColor3 = initTxtColor; btn.TextSize = THEME.TextSize; btn.AutoButtonColor = false; btn.ClipsDescendants = true; Instance.new("UICorner", btn).CornerRadius = UDim.new(0, THEME.CornerRadius); local stroke = Instance.new("UIStroke", btn); stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border; stroke.Color = THEME.ButtonOutline; stroke.Thickness = THEME.ButtonOutlineThickness; stroke.Transparency = THEME.StrokeTransparency; local uiScale = Instance.new("UIScale", btn); uiScale.Scale = 1; btn:SetAttribute("Hovering", false); btn:SetAttribute("Tooltip", ttipText or ""); btn:SetAttribute("CurrentTextColor", initTxtColor); local hvrTweenInfo = TweenInfo.new(THEME.AnimationSpeed, Enum.EasingStyle.Sine, Enum.EasingDirection.Out); local prsTweenInfo = TweenInfo.new(THEME.AnimationSpeed * 0.6, Enum.EasingStyle.Sine, Enum.EasingDirection.Out); local sclTweenInfo = TweenInfo.new(THEME.AnimationSpeed, Enum.EasingStyle.Back, Enum.EasingDirection.Out); btn.MouseEnter:Connect(function() btn:SetAttribute("Hovering", true); TS:Create(stroke, hvrTweenInfo, { Color = THEME.ButtonOutlineHover }):Play(); TS:Create(btn, hvrTweenInfo, { BackgroundColor3 = THEME.ButtonBackgroundHover }):Play(); TS:Create(uiScale, sclTweenInfo, { Scale = THEME.ScaleFactorHover }):Play(); if btn:GetAttribute("Tooltip") ~= "" then showTooltip(btn, btn:GetAttribute("Tooltip")) end end); btn.MouseLeave:Connect(function() btn:SetAttribute("Hovering", false); TS:Create(stroke, hvrTweenInfo, { Color = THEME.ButtonOutline }):Play(); TS:Create(btn, hvrTweenInfo, { BackgroundColor3 = THEME.ButtonBackground }):Play(); TS:Create(uiScale, sclTweenInfo, { Scale = 1 }):Play(); hideTooltip() end); btn.MouseButton1Down:Connect(function() TS:Create(uiScale, prsTweenInfo, { Scale = THEME.ScaleFactorPress }):Play(); hideTooltip() end); btn.MouseButton1Up:Connect(function() local targetScale = btn:GetAttribute("Hovering") and THEME.ScaleFactorHover or 1; local targetBgColor = btn:GetAttribute("Hovering") and THEME.ButtonBackgroundHover or THEME.ButtonBackground; local targetOutlineColor = btn:GetAttribute("Hovering") and THEME.ButtonOutlineHover or THEME.ButtonOutline; TS:Create(uiScale, sclTweenInfo, { Scale = targetScale }):Play(); TS:Create(btn, hvrTweenInfo, { BackgroundColor3 = targetBgColor }):Play(); TS:Create(stroke, hvrTweenInfo, { Color = targetOutlineColor }):Play(); if btn:GetAttribute("Hovering") and btn:GetAttribute("Tooltip") ~= "" then showTooltip(btn, btn:GetAttribute("Tooltip")) end end); return btn end
function updSliderStyle(sliderCont, val, isEnabled) if not sliderCont or not sliderCont:IsA("Frame") then return end local valLbl = sliderCont:FindFirstChild("ValueLabel") local sliderTrack = sliderCont:FindFirstChild("SliderTrack") if not valLbl or not sliderTrack then return end local sliderFill = sliderTrack:FindFirstChild("SliderFill") local sliderThumb = sliderTrack:FindFirstChild("SliderThumb") if not sliderFill or not sliderThumb then return end local minVal = sliderCont:GetAttribute("MinValue") or 0 local maxVal = sliderCont:GetAttribute("MaxValue") or 100 local range = maxVal - minVal if range <= 0 then range = 1 end local perc = math.clamp((val - minVal) / range, 0, 1) sliderThumb.Position = UDim2.new(perc, 0, 0.5, 0) sliderFill.Size = UDim2.new(perc, 0, 1, 0) valLbl.Text = tostring(math.floor(val)) local thumbClr = isEnabled and THEME.AccentAlt or THEME.Tertiary local fillClr = isEnabled and THEME.Accent or THEME.Tertiary local valClr = isEnabled and THEME.Text or THEME.TextDisabled local trackClr = isEnabled and THEME.SliderTrack or THEME.SliderTrackDisabled local thumbBorderClr = isEnabled and THEME.SliderThumbBorder or THEME.SliderThumbBorderDisabled sliderThumb.BackgroundColor3 = thumbClr sliderFill.BackgroundColor3 = fillClr valLbl.TextColor3 = valClr sliderTrack.BackgroundColor3 = trackClr sliderThumb.BorderColor3 = thumbBorderClr end
function setSliderOn(sliderCont, enabled) if not sliderCont or not sliderCont:IsA("Frame") then return end sliderCont:SetAttribute("Enabled", enabled) local valLbl = sliderCont:FindFirstChild("ValueLabel") local currVal = tonumber(valLbl and valLbl.Text or sliderCont:GetAttribute("InitialValue") or 0) updSliderStyle(sliderCont, currVal, enabled) end
function setSliderVal(sliderCont, val) if not sliderCont or not sliderCont:IsA("Frame") then return end local minVal = sliderCont:GetAttribute("MinValue") or 0 local maxVal = sliderCont:GetAttribute("MaxValue") or 100 local clampedVal = math.clamp(val, minVal, maxVal) local isEnabled = sliderCont:GetAttribute("Enabled") updSliderStyle(sliderCont, clampedVal, isEnabled); end
function mkSlider(parent, lblText, minVal, maxVal, initVal, valChangedCb, ttipText) local cont = Instance.new("Frame"); cont.Size = UDim2.new(1, 0, 0, THEME.ElementHeight * 1.5); cont.BackgroundTransparency = 1; cont.Parent = parent; cont:SetAttribute("Tooltip", ttipText or ""); cont:SetAttribute("Enabled", true); cont:SetAttribute("MinValue", minVal); cont:SetAttribute("MaxValue", maxVal); cont:SetAttribute("InitialValue", initVal); local lbl = Instance.new("TextLabel", cont); lbl.Size = UDim2.new(0.7, 0, 0, THEME.SmallElementHeight); lbl.Position = UDim2.new(0, 0, 0, 0); lbl.BackgroundTransparency = 1; lbl.TextColor3 = THEME.TextDisabled; lbl.Font = THEME.Font; lbl.TextSize = THEME.SmallTextSize; lbl.Text = lblText; lbl.TextXAlignment = Enum.TextXAlignment.Left; local valLbl = Instance.new("TextLabel", cont); valLbl.Name = "ValueLabel"; valLbl.Size = UDim2.new(0.3, 0, 0, THEME.SmallElementHeight); valLbl.Position = UDim2.new(0.7, 0, 0, 0); valLbl.BackgroundTransparency = 1; valLbl.TextColor3 = THEME.Text; valLbl.Font = THEME.Font; valLbl.TextSize = THEME.SmallTextSize; valLbl.Text = tostring(math.floor(initVal)); valLbl.TextXAlignment = Enum.TextXAlignment.Right; local sliderTrack = Instance.new("Frame", cont); sliderTrack.Name = "SliderTrack"; sliderTrack.Size = UDim2.new(1, 0, 0, THEME.SliderHeight + 6); sliderTrack.Position = UDim2.new(0, 0, 1, -(THEME.SliderHeight + 6) - 4); sliderTrack.BackgroundColor3 = THEME.SliderTrack; Instance.new("UICorner", sliderTrack).CornerRadius = UDim.new(0, (THEME.SliderHeight + 6) / 2); local trackStroke = Instance.new("UIStroke", sliderTrack); trackStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border; trackStroke.Color = THEME.Tertiary; trackStroke.Thickness = 1; trackStroke.Transparency = 0.7; local sliderFill = Instance.new("Frame", sliderTrack); sliderFill.Name = "SliderFill"; sliderFill.Size = UDim2.new(0,0,1,0); sliderFill.BackgroundColor3 = THEME.Accent; sliderFill.BorderSizePixel = 0; Instance.new("UICorner", sliderFill).CornerRadius = UDim.new(0, (THEME.SliderHeight + 6) / 2); local sliderThumb = Instance.new("Frame", sliderTrack); sliderThumb.Name = "SliderThumb"; local thumbActualSize = THEME.SliderThumbSize; sliderThumb.Size = UDim2.fromOffset(thumbActualSize, thumbActualSize); sliderThumb.AnchorPoint = Vector2.new(0.5, 0.5); sliderThumb.Position = UDim2.new(0, 0, 0.5, 0); sliderThumb.BackgroundColor3 = THEME.AccentAlt; sliderThumb.BorderSizePixel = 2; sliderThumb.BorderColor3 = THEME.SliderThumbBorder; Instance.new("UICorner", sliderThumb).CornerRadius = UDim.new(0.5, 0); local thumbScale = Instance.new("UIScale", sliderThumb); thumbScale.Scale = 1; local dragging = false; local inputChangedCn = nil; local inputEndedCn = nil; local thumbTweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Back, Enum.EasingDirection.Out); local function updSlider(inputPos) if not cont:GetAttribute("Enabled") then return end local relPos = sliderTrack.AbsolutePosition; local trackSize = sliderTrack.AbsoluteSize; if trackSize.X <= 0 then return end local thumbRadius = sliderThumb.AbsoluteSize.X / 2; local usableWidth = trackSize.X - (thumbRadius * 2); if usableWidth <=0 then usableWidth = 1 end local rawX = inputPos.X - relPos.X - thumbRadius; local perc = math.clamp(rawX / usableWidth, 0, 1); local val = minVal + (maxVal - minVal) * perc; local newVal = math.floor(val); updSliderStyle(cont, newVal, true); if valChangedCb then valChangedCb(newVal); end end; updSliderStyle(cont, initVal, true);
	local function onInputBegan(input) if not cont:GetAttribute("Enabled") then return end; if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then dragging = true; TS:Create(thumbScale, thumbTweenInfo, {Scale = 1.1}):Play(); updSlider(input.Position); hideTooltip(); if inputChangedCn then inputChangedCn:Disconnect() end; if inputEndedCn then inputEndedCn:Disconnect() end; inputEndedCn = input.Changed:Connect(function() if input.UserInputState == Enum.UserInputState.End then dragging = false; TS:Create(thumbScale, thumbTweenInfo, {Scale = 1}):Play(); if inputChangedCn then inputChangedCn:Disconnect(); inputChangedCn = nil end; if inputEndedCn then inputEndedCn:Disconnect(); inputEndedCn = nil end end end); inputChangedCn = RuS.RenderStepped:Connect(function() if dragging then updSlider(UIS:GetMouseLocation()) else if inputChangedCn then inputChangedCn:Disconnect(); inputChangedCn = nil end end end) end end; sliderTrack.InputBegan:Connect(onInputBegan); sliderThumb.InputBegan:Connect(onInputBegan); cont.MouseEnter:Connect(function() if cont:GetAttribute("Tooltip") ~= "" and not dragging then showTooltip(cont, cont:GetAttribute("Tooltip")) end end); cont.MouseLeave:Connect(function() if not dragging then hideTooltip() end end); return cont, valLbl end
local function toggleStealth()
	stealthMode = not stealthMode
	local targetTtip = stealthMode and "Switch to Normal Mode" or "Switch to Stealth Mode"
	local targetStrokeClr = stealthMode and THEME.Error or THEME.Accent
	local targetCoreClr = stealthMode and THEME.Error or THEME.Accent
	local stealthBtnClickArea = GuiElems.stealthModeClickBtn
    local stealthBtnCont = GuiElems.stealthModeStroke and GuiElems.stealthModeStroke.Parent

	if stealthBtnClickArea then stealthBtnClickArea:SetAttribute("Tooltip", targetTtip) end
	if GuiElems.stealthModeStroke then TS:Create(GuiElems.stealthModeStroke, DimTweenInfo, { Color = targetStrokeClr }):Play() end
	if GuiElems.stealthModeCore then TS:Create(GuiElems.stealthModeCore, DimTweenInfo, { BackgroundColor3 = targetCoreClr }):Play() end

    if stealthBtnCont then
        local pulseScale = stealthBtnCont:FindFirstChildWhichIsA("UIScale") or Instance.new("UIScale", stealthBtnCont)
        local pressTweenInfo = TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        local releaseTweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
        local s1 = TS:Create(pulseScale, pressTweenInfo, {Scale = 0.9})
        local s2 = TS:Create(pulseScale, releaseTweenInfo, {Scale = 1})
        s1.Completed:Connect(function() s2:Play() end); s1:Play()
    end

	local targetBgTrans = stealthMode and 0.5 or 0; local targetTxtTrans = stealthMode and 0.3 or 0;
	local btnsToFade = {GuiElems.fovChangerBtn, GuiElems.resetFovBtn, GuiElems.espBtn}
	for _, btn in ipairs(btnsToFade) do if btn then TS:Create(btn, DimTweenInfo, {BackgroundTransparency = targetBgTrans}):Play(); TS:Create(btn, DimTweenInfo, {TextTransparency = targetTxtTrans}):Play(); end end

	if stealthMode then
		fovChangerOn = false; Cam.FieldOfView = gameDefFOV;
		if GuiElems.fovChangerBtn then GuiElems.fovChangerBtn.Text = "FOV: OFF"; GuiElems.fovChangerBtn.TextColor3 = THEME.Error; GuiElems.fovChangerBtn:SetAttribute("CurrentTextColor", THEME.Error); end
		if GuiElems.camFovSliderCont then setSliderOn(GuiElems.camFovSliderCont, false); setSliderVal(GuiElems.camFovSliderCont, gameDefFOV); end
		if espOn then toggleESP(false) end
	else
		if GuiElems.fovChangerBtn then local initFovTxtClr = fovChangerOn and THEME.Success or THEME.Error; GuiElems.fovChangerBtn.TextColor3 = initFovTxtClr; GuiElems.fovChangerBtn:SetAttribute("CurrentTextColor", initFovTxtClr); GuiElems.fovChangerBtn.Text = fovChangerOn and "FOV: ON" or "FOV: OFF"; end
		if GuiElems.camFovSliderCont then setSliderOn(GuiElems.camFovSliderCont, fovChangerOn); setSliderVal(GuiElems.camFovSliderCont, fovChangerOn and camFOV or gameDefFOV); end
		if GuiElems.espBtn then local initEspTxtClr = espOn and THEME.Success or THEME.Error; GuiElems.espBtn.TextColor3 = initEspTxtClr; GuiElems.espBtn:SetAttribute("CurrentTextColor", initEspTxtClr); GuiElems.espBtn.Text = espOn and "ESP: ON" or "ESP: OFF"; end
	end
	updFOVCircle(); updAllExclLblsVis();
end

function createGUI()
	local oldGui = pGui:FindFirstChild("TheMistGUI_DelaySwitcher_V24"); if oldGui then oldGui:Destroy() end
	local gui = Instance.new("ScreenGui", pGui); gui.Name = "TheMistGUI_DelaySwitcher_V24"; gui.ResetOnSpawn = false; gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling; gui.DisplayOrder = 999;

	mainFrm = Instance.new("Frame", gui);
    mainFrm.Visible = false
	mainFrm.AnchorPoint = Vector2.new(0, 0.5);
	mainFrm.Size = UDim2.fromScale(0, 0);
	mainFrm.AutomaticSize = Enum.AutomaticSize.Y;
	mainFrm.BackgroundColor3 = THEME.Background;
	mainFrm.BackgroundTransparency = 0
	mainFrm.BorderSizePixel = 0;
	mainFrm.ClipsDescendants = true;
	mainFrm.ZIndex = 5;
	mainFrm.Active = true;
	mainFrm.Draggable = false;
	Instance.new("UICorner", mainFrm).CornerRadius = UDim.new(0, THEME.CornerRadius);
	local sizeConst = Instance.new("UISizeConstraint", mainFrm); sizeConst.MinSize = Vector2.new(THEME.PanelMinWidth, 190); sizeConst.MaxSize = Vector2.new(THEME.PanelMaxWidth, math.huge);

	local bgGrad = Instance.new("UIGradient", mainFrm); bgGrad.Rotation = 135; bgGrad.Color = ColorSequence.new({ ColorSequenceKeypoint.new(0, THEME.BackgroundSlightlyLighter), ColorSequenceKeypoint.new(0.3, THEME.Background), ColorSequenceKeypoint.new(0.5, THEME.Primary), ColorSequenceKeypoint.new(0.8, THEME.BackgroundSubtleVariant), ColorSequenceKeypoint.new(1, THEME.BackgroundSlightlyLighter), }); bgGrad.Offset = Vector2.new(-1, -1);
	local pad = Instance.new("UIPadding", mainFrm); pad.PaddingTop = UDim.new(0, THEME.Padding); pad.PaddingBottom = UDim.new(0, THEME.Padding); pad.PaddingLeft = UDim.new(0, THEME.Padding); pad.PaddingRight = UDim.new(0, THEME.Padding);
	local listLayout = Instance.new("UIListLayout", mainFrm); listLayout.Padding = UDim.new(0, THEME.Padding); listLayout.SortOrder = Enum.SortOrder.LayoutOrder; listLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center; listLayout.FillDirection = Enum.FillDirection.Vertical;

	getTTipLabel(gui)

	local titleFrm = Instance.new("Frame", mainFrm); titleFrm.Size = UDim2.new(1, 0, 0, THEME.TitleSize + 2); titleFrm.BackgroundTransparency = 1; titleFrm.LayoutOrder = 0;
	local titleLbl = Instance.new("TextLabel", titleFrm); titleLbl.Size = UDim2.new(1, -25, 1, 0); titleLbl.Position = UDim2.fromOffset(0, 0); titleLbl.BackgroundTransparency = 1; titleLbl.Text = "THE MIST"; titleLbl.TextColor3 = THEME.Accent; titleLbl.Font = THEME.FontTitle; titleLbl.TextSize = THEME.TitleSize; titleLbl.TextXAlignment = Enum.TextXAlignment.Left;
	local subtitleLbl = Instance.new("TextLabel", mainFrm); subtitleLbl.Size = UDim2.new(1, -THEME.Padding*2, 0, THEME.SubtitleSize + 2); subtitleLbl.Position = UDim2.fromOffset(THEME.Padding, 0); subtitleLbl.BackgroundTransparency = 1;
    subtitleLbl.Text = "triggerbot-module v3.2";
    subtitleLbl.TextColor3 = THEME.TextDisabled; subtitleLbl.Font = THEME.Font; subtitleLbl.TextSize = THEME.SubtitleSize; subtitleLbl.LayoutOrder = 1; subtitleLbl.TextXAlignment = Enum.TextXAlignment.Left;
	local stealthCont = Instance.new("Frame", titleFrm); stealthCont.Name = "StealthModeContainer"; stealthCont.Size = UDim2.fromOffset(18, 18); stealthCont.AnchorPoint = Vector2.new(1, 0.5); stealthCont.Position = UDim2.new(1, -THEME.Padding, 0.5, 0); stealthCont.BackgroundColor3 = THEME.Primary; stealthCont.BackgroundTransparency = 0.3; Instance.new("UICorner", stealthCont).CornerRadius = UDim.new(0, 4); local scStroke = Instance.new("UIStroke", stealthCont); scStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border; scStroke.Color = stealthMode and THEME.Error or THEME.Accent; scStroke.Thickness = 1.5; scStroke.Transparency = 0.2; GuiElems.stealthModeStroke = scStroke; local scCore = Instance.new("Frame", stealthCont); scCore.Name = "Core"; scCore.Size = UDim2.fromScale(0.5, 0.5); scCore.AnchorPoint = Vector2.new(0.5, 0.5); scCore.Position = UDim2.fromScale(0.5, 0.5); scCore.BackgroundColor3 = stealthMode and THEME.Error or THEME.Accent; scCore.BackgroundTransparency = 0.1; Instance.new("UICorner", scCore).CornerRadius = UDim.new(0.5, 0); GuiElems.stealthModeCore = scCore; local stealthClickBtn = Instance.new("TextButton", stealthCont); stealthClickBtn.Name = "StealthClickArea"; stealthClickBtn.Size = UDim2.fromScale(1, 1); stealthClickBtn.BackgroundTransparency = 1; stealthClickBtn.Text = ""; stealthClickBtn.ZIndex = 2; stealthClickBtn:SetAttribute("Tooltip", stealthMode and "Switch to Normal Mode" or "Switch to Stealth Mode"); GuiElems.stealthModeClickBtn = stealthClickBtn; local scScale = Instance.new("UIScale", stealthCont); scScale.Scale = 1; local hvrTweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out); stealthClickBtn.MouseEnter:Connect(function() TS:Create(scScale, hvrTweenInfo, {Scale = 1.1}):Play(); local currStrokeClr = stealthMode and THEME.Error or THEME.Accent; TS:Create(scStroke, hvrTweenInfo, {Color = currStrokeClr:Lerp(Color3.new(1,1,1), 0.3), Transparency = 0}):Play(); if stealthClickBtn:GetAttribute("Tooltip") ~= "" then showTooltip(stealthClickBtn, stealthClickBtn:GetAttribute("Tooltip")) end end); stealthClickBtn.MouseLeave:Connect(function() TS:Create(scScale, hvrTweenInfo, {Scale = 1}):Play(); local currStrokeClr = stealthMode and THEME.Error or THEME.Accent; TS:Create(scStroke, hvrTweenInfo, {Color = currStrokeClr, Transparency = 0.2}):Play(); hideTooltip(); end); stealthClickBtn.MouseButton1Click:Connect(toggleStealth);
	local mainControlsFrm = Instance.new("Frame", mainFrm); mainControlsFrm.Size = UDim2.new(1, 0, 0, THEME.ElementHeight * 2 + THEME.Padding); mainControlsFrm.BackgroundTransparency = 1; mainControlsFrm.LayoutOrder = 2; local mainControlsLayout = Instance.new("UIListLayout", mainControlsFrm); mainControlsLayout.Padding = UDim.new(0, THEME.Padding); mainControlsLayout.SortOrder = Enum.SortOrder.LayoutOrder; mainControlsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center; local initAutoTargetTxtClr = autoTargetOn and THEME.Success or THEME.Error; local initEspTxtClr = espOn and THEME.Success or THEME.Error; GuiElems.autoTargetBtn = mkBtn(mainControlsFrm, "TARGET: OFF", initAutoTargetTxtClr, UDim2.new(), UDim2.new(1,0,0,THEME.ElementHeight), "Toggle Auto Targeting"); GuiElems.espBtn = mkBtn(mainControlsFrm, "ESP: ON", initEspTxtClr, UDim2.new(), UDim2.new(1,0,0,THEME.ElementHeight), "Toggle Player ESP"); GuiElems.autoTargetBtn.Text = autoTargetOn and "TARGET: ON" or "TARGET: OFF"; GuiElems.espBtn.Text = espOn and "ESP: ON" or "ESP: OFF"; GuiElems.espBtn.BackgroundTransparency = stealthMode and 0.5 or 0; GuiElems.espBtn.TextTransparency = stealthMode and 0.3 or 0;
	local settingsFrm = Instance.new("Frame", mainFrm); settingsFrm.Size = UDim2.new(1, 0, 0, 0); settingsFrm.AutomaticSize = Enum.AutomaticSize.Y; settingsFrm.BackgroundTransparency = 1; settingsFrm.LayoutOrder = 4; local settingsLayout = Instance.new("UIListLayout", settingsFrm); settingsLayout.Padding = UDim.new(0, THEME.Padding + 2); settingsLayout.SortOrder = Enum.SortOrder.LayoutOrder; settingsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center; settingsLayout.FillDirection = Enum.FillDirection.Vertical;

    local targetFovSliderCont, targetFovValLbl = mkSlider(settingsFrm, "Target FOV", 0, 180, targetFOV, function(val) targetFOV = val; updFOVCircle() end, "Aim assist Field of View (degrees)"); GuiElems.targetFovSliderCont = targetFovSliderCont; GuiElems.targetFovValLbl = targetFovValLbl;
    targetFovSliderCont.LayoutOrder = 1

    local delaySwitcherFrm = Instance.new("TextButton", settingsFrm)
    delaySwitcherFrm.Name = "DelayModeSwitcherFrame"
    delaySwitcherFrm.Size = UDim2.new(1, 0, 0, THEME.ElementHeight)
    delaySwitcherFrm.BackgroundTransparency = 1
    delaySwitcherFrm.Text = ""
    delaySwitcherFrm.AutoButtonColor = false
    delaySwitcherFrm.LayoutOrder = 2
    delaySwitcherFrm:SetAttribute("Tooltip", "Click to switch delay mode")

    local switchTrack = Instance.new("Frame", delaySwitcherFrm)
    switchTrack.Name = "Track"
    switchTrack.Size = UDim2.new(1, -20, 1, -4)
    switchTrack.AnchorPoint = Vector2.new(0.5, 0.5)
    switchTrack.Position = UDim2.fromScale(0.5, 0.5)
    switchTrack.BackgroundColor3 = THEME.PrimaryLighter
    switchTrack.BackgroundTransparency = 0.5
    Instance.new("UICorner", switchTrack).CornerRadius = UDim.new(0, THEME.CornerRadius);
    local trackStroke = Instance.new("UIStroke", switchTrack); trackStroke.Color = THEME.Secondary; trackStroke.Transparency = 0.6; trackStroke.Thickness = 1;

    local switchThumb = Instance.new("Frame", switchTrack)
    switchThumb.Name = "Thumb"
    switchThumb.Size = UDim2.new(0.5, -2, 1, -4)
    switchThumb.Position = UDim2.fromScale(0, 0.5)
    switchThumb.AnchorPoint = Vector2.new(0, 0.5)
    switchThumb.BackgroundColor3 = THEME.Accent
    switchThumb.BorderSizePixel = 0
    Instance.new("UICorner", switchThumb).CornerRadius = UDim.new(0, THEME.CornerRadius - 2);
    GuiElems.delaySwitcherThumb = switchThumb

    local lblBlatant = Instance.new("TextLabel", switchTrack)
    lblBlatant.Name = "LabelBlatant"
    lblBlatant.Size = UDim2.new(0.5, 0, 1, 0)
    lblBlatant.Position = UDim2.fromScale(0, 0.5)
    lblBlatant.AnchorPoint = Vector2.new(0, 0.5)
    lblBlatant.BackgroundTransparency = 1
    lblBlatant.Font = THEME.Font
    lblBlatant.Text = "Blatant"
    lblBlatant.TextSize = THEME.SmallTextSize
    lblBlatant.TextColor3 = THEME.TextDisabled
    lblBlatant.TextXAlignment = Enum.TextXAlignment.Center
    GuiElems.delayLblBlatant = lblBlatant

    local lblNormal = Instance.new("TextLabel", switchTrack)
    lblNormal.Name = "LabelNormal"
    lblNormal.Size = UDim2.new(0.5, 0, 1, 0)
    lblNormal.Position = UDim2.fromScale(0.5, 0.5)
    lblNormal.AnchorPoint = Vector2.new(0, 0.5)
    lblNormal.BackgroundTransparency = 1
    lblNormal.Font = THEME.Font
    lblNormal.Text = "Normal"
    lblNormal.TextSize = THEME.SmallTextSize
    lblNormal.TextColor3 = THEME.Text
    lblNormal.TextXAlignment = Enum.TextXAlignment.Center
    GuiElems.delayLblNormal = lblNormal

    local function updSwitcherVis(newMode, skipAnim)
        local targetThumbPos = (newMode == "Blatant") and UDim2.fromScale(0, 0.5) or UDim2.fromScale(0.5, 0.5)
        local blatantClr = (newMode == "Blatant") and THEME.TextActive or THEME.TextDisabled
        local normalClr = (newMode == "Normal") and THEME.TextActive or THEME.TextDisabled

        if skipAnim then
            switchThumb.Position = targetThumbPos
            lblBlatant.TextColor3 = blatantClr
            lblNormal.TextColor3 = normalClr
        else
            TS:Create(switchThumb, SwitchAnimInfo, { Position = targetThumbPos }):Play()
            TS:Create(lblBlatant, TxtColorTweenInfo, { TextColor3 = blatantClr }):Play()
            TS:Create(lblNormal, TxtColorTweenInfo, { TextColor3 = normalClr }):Play()
        end
    end

    delaySwitcherFrm.MouseButton1Click:Connect(function()
        hideTooltip()
        if delayMode == "Normal" then
            delayMode = "Blatant"
            shootDelayMs = 0
            updSwitcherVis("Blatant")
        else
            delayMode = "Normal"
            shootDelayMs = 264
            updSwitcherVis("Normal")
        end
    end)
    delaySwitcherFrm.MouseEnter:Connect(function() if delaySwitcherFrm:GetAttribute("Tooltip") ~= "" then showTooltip(delaySwitcherFrm, delaySwitcherFrm:GetAttribute("Tooltip")) end end)
    delaySwitcherFrm.MouseLeave:Connect(hideTooltip)
    updSwitcherVis(delayMode, true)

    local camFovSliderCont, camFovValLbl = mkSlider(settingsFrm, "Camera FOV", 30, 120, camFOV, function(val) if fovChangerOn then camFOV = val; Cam.FieldOfView = val; updFOVCircle() end end, "Camera Field of View (degrees)"); GuiElems.camFovSliderCont = camFovSliderCont; GuiElems.camFovValLbl = camFovValLbl;
    camFovSliderCont.LayoutOrder = 3

    local fovControlFrm = Instance.new("Frame", settingsFrm); fovControlFrm.Size = UDim2.new(1, 0, 0, THEME.SmallElementHeight * 2 + THEME.Padding); fovControlFrm.BackgroundTransparency = 1; fovControlFrm.LayoutOrder = 4; local fovControlLayout = Instance.new("UIListLayout", fovControlFrm); fovControlLayout.Padding = UDim.new(0, THEME.Padding); fovControlLayout.SortOrder = Enum.SortOrder.LayoutOrder; fovControlLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center; local initFovTxtClr = fovChangerOn and THEME.Success or THEME.Error; GuiElems.fovChangerBtn = mkBtn(fovControlFrm, "FOV: ON", initFovTxtClr, UDim2.new(), UDim2.new(1,0,0,THEME.SmallElementHeight), "Toggle Camera FOV Changer"); GuiElems.resetFovBtn = mkBtn(fovControlFrm, "RESET", THEME.ButtonText, UDim2.new(), UDim2.new(1,0,0,THEME.SmallElementHeight), "Reset Camera FOV to Game Default ("..tostring(math.floor(gameDefFOV))..")"); GuiElems.fovChangerBtn.TextSize = THEME.SmallTextSize; GuiElems.resetFovBtn.TextSize = THEME.SmallTextSize; GuiElems.fovChangerBtn.Text = fovChangerOn and "FOV: ON" or "FOV: OFF"; GuiElems.fovChangerBtn.BackgroundTransparency = stealthMode and 0.5 or 0; GuiElems.fovChangerBtn.TextTransparency = stealthMode and 0.3 or 0; GuiElems.resetFovBtn.BackgroundTransparency = stealthMode and 0.5 or 0; GuiElems.resetFovBtn.TextTransparency = stealthMode and 0.3 or 0; setSliderOn(GuiElems.camFovSliderCont, not stealthMode and fovChangerOn);

	local listTitle = Instance.new("TextLabel", mainFrm); listTitle.Size = UDim2.new(1, -THEME.Padding*2, 0, THEME.SmallElementHeight); listTitle.Position = UDim2.fromOffset(THEME.Padding, 0); listTitle.BackgroundTransparency = 1; listTitle.Text = "NEARBY ENTITIES"; listTitle.TextColor3 = THEME.TextDisabled; listTitle.Font = THEME.Font; listTitle.TextSize = THEME.SmallTextSize; listTitle.TextXAlignment = Enum.TextXAlignment.Left; listTitle.LayoutOrder = 6; local plrListHeight = 90; local plrListFrm = Instance.new("ScrollingFrame", mainFrm); plrListFrm.Size = UDim2.new(1, 0, 0, plrListHeight); plrListFrm.BackgroundTransparency = 1; plrListFrm.BackgroundColor3 = THEME.Background; plrListFrm.BorderSizePixel = 0; plrListFrm.LayoutOrder = 7; plrListFrm.ScrollBarThickness = 3; plrListFrm.ScrollBarImageColor3 = THEME.Accent; plrListFrm.CanvasSize = UDim2.new(0, 0, 0, 0); plrListFrm.AutomaticCanvasSize = Enum.AutomaticSize.Y; plrListFrm.ClipsDescendants = true; Instance.new("UICorner", plrListFrm).CornerRadius = UDim.new(0, THEME.CornerRadius / 2); local listStroke = Instance.new("UIStroke", plrListFrm); listStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border; listStroke.Color = THEME.Tertiary; listStroke.Thickness = THEME.StrokeThickness; listStroke.Transparency = 0.6; local plrListLayout = Instance.new("UIListLayout", plrListFrm); plrListLayout.Padding = UDim.new(0, 3); plrListLayout.SortOrder = Enum.SortOrder.LayoutOrder; plrListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center; plrListLayout.FillDirection = Enum.FillDirection.Vertical; local listPad = Instance.new("UIPadding", plrListFrm); listPad.PaddingLeft = UDim.new(0, 2); listPad.PaddingRight = UDim.new(0, 2); listPad.PaddingTop = UDim.new(0, 2); listPad.PaddingBottom = UDim.new(0, 2); GuiElems.plrListFrm = plrListFrm; GuiElems.plrListLayout = plrListLayout;
	local footerFrm = Instance.new("Frame", mainFrm); footerFrm.Size = UDim2.new(1, 0, 0, 0); footerFrm.AutomaticSize = Enum.AutomaticSize.Y; footerFrm.BackgroundTransparency = 1; footerFrm.LayoutOrder = 100; local footerLayout = Instance.new("UIListLayout", footerFrm); footerLayout.Padding = UDim.new(0, 0); footerLayout.SortOrder = Enum.SortOrder.LayoutOrder; footerLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center; footerLayout.FillDirection = Enum.FillDirection.Vertical; local disclaimerLbl = Instance.new("TextLabel", footerFrm); disclaimerLbl.Name = "DisclaimerLabel"; disclaimerLbl.Size = UDim2.new(1, -THEME.Padding*2, 0, THEME.DisclaimerSize + 4); disclaimerLbl.BackgroundTransparency = 1; disclaimerLbl.Font = THEME.Font; disclaimerLbl.Text = "Module executed via THE MIST HUB."; disclaimerLbl.TextColor3 = THEME.TextDisabled; disclaimerLbl.TextSize = THEME.DisclaimerSize; disclaimerLbl.TextWrapped = false; disclaimerLbl.TextXAlignment = Enum.TextXAlignment.Center; disclaimerLbl.LayoutOrder = 1; Instance.new("UIPadding", disclaimerLbl).PaddingTop = UDim.new(0, 4);

	task.wait()

	local currAbsWidth = mainFrm.AbsoluteSize.X
	if currAbsWidth <= 0 then currAbsWidth = sizeConst.MaxSize.X end
	if currAbsWidth <= 0 then currAbsWidth = THEME.PanelMaxWidth end
    local initHiddenX = -(currAbsWidth + 20)
	mainFrm.Position = UDim2.new(0, initHiddenX, 0.5, 0)

    task.delay(0.4, function()
        if mainFrm and mainFrm.Parent then mainFrm.Visible = true end
    end)

    local function animBg() while gui and gui.Parent and mainFrm and mainFrm.Parent do local animSpd = 30; local startOff = Vector2.new(-1, -1); local endOff = Vector2.new(2, 2); bgGrad.Offset = startOff; local bgTween = TS:Create(bgGrad, TweenInfo.new(animSpd, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {Offset = endOff}); bgTween:Play(); bgTween.Completed:Wait(); task.wait(0.1); end end; task.spawn(animBg);

	local panelTween = nil; local slideTweenInfo = TweenInfo.new(0.35, Enum.EasingStyle.Cubic, Enum.EasingDirection.Out);
    local toggleArea = Instance.new("TextButton", gui);
    toggleArea.Name = "InvisibleToggleArea";
    toggleArea.Size = UDim2.new(0, 80, 0, 80);
    toggleArea.AnchorPoint = Vector2.new(0, 1);
    toggleArea.Position = UDim2.new(0, 10, 1, -10);
    toggleArea.BackgroundTransparency = 1;
    toggleArea.Text = "";
    toggleArea.ZIndex = 10;
	toggleArea.MouseButton1Click:Connect(function() panelVis = not panelVis; hideTooltip(); local targetXOff; local safeInset = GS:GetGuiInset(); local currAbsWidth = mainFrm.AbsoluteSize.X; if currAbsWidth <= 0 then local sizeConst = mainFrm:FindFirstChildOfClass("UISizeConstraint"); currAbsWidth = sizeConst and sizeConst.MaxSize.X or THEME.PanelMaxWidth end; if panelVis then targetXOff = safeInset.X + 10; mainFrm.Visible = true; else targetXOff = -(currAbsWidth + 20); end; local targetPos = UDim2.new(0, targetXOff, 0.5, 0); if panelTween and panelTween.PlaybackState == Enum.PlaybackState.Playing then panelTween:Cancel() end; panelTween = TS:Create(mainFrm, slideTweenInfo, {Position = targetPos}); if not panelVis then panelTween.Completed:Connect(function(state) if state == Enum.TweenStatus.Completed and not panelVis then mainFrm.Visible = false end end) end; panelTween:Play(); updFOVCircle(); updAllExclLblsVis(); end)
	local listHvrTweenInfo = TweenInfo.new(0.1); local function updPlrListGUI() if not GuiElems.plrListFrm or not GuiElems.plrListFrm.Parent then return end; if not char or not char:FindFirstChild("HumanoidRootPart") then return end; local existingBtns = {}; for _, child in ipairs(GuiElems.plrListFrm:GetChildren()) do if child:IsA("TextButton") and child.Name:match("_Entry$") then local userIdAttr = child:GetAttribute("PlayerUserId"); if userIdAttr then existingBtns[userIdAttr] = child end end end; local nearby = {}; local plrRootPos = char.HumanoidRootPart.Position; local dispRange = 50; for _, p_ in pairs(P:GetPlayers()) do if p_ ~= plr and p_.Character and p_.Character:FindFirstChild("HumanoidRootPart") then local targetHum = p_.Character:FindFirstChildOfClass("Humanoid"); if targetHum and targetHum.Health > 0 then local targetRootPos = p_.Character.HumanoidRootPart.Position; local dist = (plrRootPos - targetRootPos).Magnitude; if dist <= dispRange then table.insert(nearby, {Player = p_, Dist = dist}) end end end end; table.sort(nearby, function(a, b) return a.Dist < b.Dist end); local plrsInList = {}; for i, data in ipairs(nearby) do local p_ = data.Player; local userId = p_.UserId; plrsInList[userId] = true; local btn = existingBtns[userId]; if btn then btn.LayoutOrder = i; local distLbl = btn:FindFirstChild("DistLabel", true); if distLbl then distLbl.Text = math.floor(data.Dist) .. "m" end; local isExcl = excludedPlrs[p_]; local nameLbl = btn:FindFirstChild("NameLabel", true); if nameLbl then nameLbl.TextColor3 = isExcl and THEME.RefExcludedColor or THEME.TextPlayerListNormal end; local exclIcon = btn:FindFirstChild("ExcludeIcon", true); if exclIcon then exclIcon.Text = isExcl and "✕" or "✓"; exclIcon.TextColor3 = isExcl and THEME.ExcludedIcon or THEME.Success; updExclLbl(p_) end; existingBtns[userId] = nil else btn = Instance.new("TextButton"); btn.Name = p_.Name .. "_Entry"; btn.Size = UDim2.new(1, 0, 0, THEME.SmallElementHeight); btn.BackgroundColor3 = THEME.Primary; btn.BackgroundTransparency = 0.1; btn.Text = ""; btn.LayoutOrder = i; btn:SetAttribute("PlayerUserId", userId); btn.Parent = GuiElems.plrListFrm; Instance.new("UICorner", btn).CornerRadius = UDim.new(0, THEME.CornerRadius / 2); local itemStroke = Instance.new("UIStroke", btn); itemStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border; itemStroke.Color = THEME.Tertiary; itemStroke.Thickness = THEME.StrokeThickness; itemStroke.Transparency = 0.7; local itemPad = Instance.new("UIPadding", btn); itemPad.PaddingLeft = UDim.new(0, 5); itemPad.PaddingRight = UDim.new(0, 5); local exclIcon = Instance.new("TextLabel", btn); exclIcon.Name = "ExcludeIcon"; exclIcon.Size = UDim2.fromOffset(12, 12); exclIcon.Position=UDim2.fromScale(0,0.5); exclIcon.AnchorPoint=Vector2.new(0,0.5); exclIcon.BackgroundTransparency = 1; exclIcon.Font = Enum.Font.SourceSansBold; local isExcl = excludedPlrs[p_]; exclIcon.Text = isExcl and "✕" or "✓"; exclIcon.TextColor3 = isExcl and THEME.ExcludedIcon or THEME.Success; exclIcon.TextSize = 14; local teamClrInd = Instance.new("Frame", btn); teamClrInd.Size = UDim2.fromOffset(5, 12); teamClrInd.Position=UDim2.fromOffset(18,0)+UDim2.fromScale(0,0.5); teamClrInd.AnchorPoint=Vector2.new(0,0.5); teamClrInd.BackgroundColor3 = p_.Team and p_.Team.TeamColor.Color or Color3.fromRGB(90,90,90); teamClrInd.BorderSizePixel = 0; Instance.new("UICorner", teamClrInd).CornerRadius = UDim.new(0, 2); local nameLbl = Instance.new("TextLabel", btn); nameLbl.Name = "NameLabel"; nameLbl.Size = UDim2.new(1, -55, 1, 0); nameLbl.Position=UDim2.fromOffset(25,0); nameLbl.BackgroundTransparency = 1; nameLbl.Font = THEME.Font; nameLbl.Text = p_.Name; nameLbl.TextColor3 = isExcl and THEME.RefExcludedColor or THEME.TextPlayerListNormal; nameLbl.TextSize = THEME.SmallTextSize; nameLbl.TextXAlignment = Enum.TextXAlignment.Left; local distLbl = Instance.new("TextLabel", btn); distLbl.Name = "DistLabel"; distLbl.Size = UDim2.new(0, 30, 1, 0); distLbl.AnchorPoint=Vector2.new(1,0.5); distLbl.Position=UDim2.fromScale(1,0.5); distLbl.BackgroundTransparency = 1; distLbl.Font = THEME.Font; distLbl.Text = math.floor(data.Dist) .. "m"; distLbl.TextColor3 = THEME.TextDisabled; distLbl.TextSize = THEME.SmallTextSize; distLbl.TextXAlignment = Enum.TextXAlignment.Right; updExclLbl(p_); btn.MouseEnter:Connect(function() TS:Create(btn, listHvrTweenInfo, {BackgroundTransparency = 0}):Play() end); btn.MouseLeave:Connect(function() TS:Create(btn, listHvrTweenInfo, {BackgroundTransparency = 0.1}):Play() end); btn.MouseButton1Click:Connect(function() excludedPlrs[p_] = not excludedPlrs[p_]; updExclLbl(p_); local isNowExcl = excludedPlrs[p_]; nameLbl.TextColor3 = isNowExcl and THEME.RefExcludedColor or THEME.TextPlayerListNormal; exclIcon.Text = isNowExcl and "✕" or "✓"; exclIcon.TextColor3 = isNowExcl and THEME.ExcludedIcon or THEME.Success; end) end end; for _, oldBtn in pairs(existingBtns) do oldBtn:Destroy() end; local itemHeight = THEME.SmallElementHeight; local padOff = plrListLayout.Padding.Offset; if GuiElems.plrListFrm and GuiElems.plrListFrm:IsA("ScrollingFrame") then local childCount = 0; for _, child in ipairs(GuiElems.plrListFrm:GetChildren()) do if child:IsA("TextButton") and child.Name:match("_Entry$") then childCount = childCount + 1 end end; local totalContentH; if childCount > 0 then totalContentH = childCount * (itemHeight + padOff) - padOff; else totalContentH = 0; end; GuiElems.plrListFrm.CanvasSize = UDim2.new(0,0,0, math.max(plrListHeight, totalContentH)); end end
	GuiElems.autoTargetBtn.MouseButton1Click:Connect(function() autoTargetOn = not autoTargetOn; local stateTxt = autoTargetOn and "TARGET: ON" or "TARGET: OFF"; local newTxtColor = autoTargetOn and THEME.Success or THEME.Error; local btn = GuiElems.autoTargetBtn; btn.Text = stateTxt; btn:SetAttribute("CurrentTextColor", newTxtColor); TS:Create(btn, TxtColorTweenInfo, { TextColor3 = newTxtColor }):Play(); updFOVCircle(); end)
	GuiElems.espBtn.MouseButton1Click:Connect(function() if stealthMode then return end; toggleESP(not espOn); end)
	GuiElems.fovChangerBtn.MouseButton1Click:Connect(function() if stealthMode then return end; fovChangerOn = not fovChangerOn; local stateTxt = fovChangerOn and "FOV: ON" or "FOV: OFF"; local newTxtColor = fovChangerOn and THEME.Success or THEME.Error; local btn = GuiElems.fovChangerBtn; btn.Text = stateTxt; btn:SetAttribute("CurrentTextColor", newTxtColor); TS:Create(btn, TxtColorTweenInfo, { TextColor3 = newTxtColor }):Play(); setSliderOn(GuiElems.camFovSliderCont, fovChangerOn); if fovChangerOn then Cam.FieldOfView = camFOV; setSliderVal(GuiElems.camFovSliderCont, camFOV); else Cam.FieldOfView = gameDefFOV; setSliderVal(GuiElems.camFovSliderCont, gameDefFOV); end; updFOVCircle(); end)
	GuiElems.resetFovBtn.MouseButton1Click:Connect(function() if stealthMode then return end; camFOV = gameDefFOV; Cam.FieldOfView = gameDefFOV; setSliderVal(GuiElems.camFovSliderCont, gameDefFOV); updFOVCircle(); local btn = GuiElems.resetFovBtn; local origTxtColor = THEME.ButtonText; btn:SetAttribute("CurrentTextColor", THEME.Accent); TS:Create(btn, TxtColorTweenInfo, {TextColor3 = THEME.Accent}):Play(); task.delay(THEME.TextColorFadeDuration * 1.1, function() if btn and btn.Parent then btn:SetAttribute("CurrentTextColor", origTxtColor); TS:Create(btn, TxtColorTweenInfo, {TextColor3 = origTxtColor}):Play() end end) end)
	local lastUpd = 0; local updInterval = 0.5; RuS.Heartbeat:Connect(function() local currTime = tick(); if panelVis and mainFrm.Position.X.Offset > -(mainFrm.AbsoluteSize.X + 10) and (currTime - lastUpd >= updInterval) then pcall(updPlrListGUI); lastUpd = currTime end end);

    local initAutoTargetTxtClr = autoTargetOn and THEME.Success or THEME.Error; GuiElems.autoTargetBtn.TextColor3 = initAutoTargetTxtClr; GuiElems.autoTargetBtn:SetAttribute("CurrentTextColor", initAutoTargetTxtClr);
	local initEspTxtClr = espOn and THEME.Success or THEME.Error; GuiElems.espBtn.TextColor3 = initEspTxtClr; GuiElems.espBtn:SetAttribute("CurrentTextColor", initEspTxtClr);
	local initFovTxtClr = fovChangerOn and THEME.Success or THEME.Error; GuiElems.fovChangerBtn.TextColor3 = initFovTxtClr; GuiElems.fovChangerBtn:SetAttribute("CurrentTextColor", initFovTxtClr);
	GuiElems.resetFovBtn.TextColor3 = THEME.ButtonText; GuiElems.resetFovBtn:SetAttribute("CurrentTextColor", THEME.ButtonText);
	setSliderOn(GuiElems.camFovSliderCont, not stealthMode and fovChangerOn);
	setSliderVal(GuiElems.camFovSliderCont, fovChangerOn and camFOV or gameDefFOV);
	setSliderVal(GuiElems.targetFovSliderCont, targetFOV);
	return gui
end

local MainGui = nil
local s, e = pcall(function()
	MainGui = createGUI();
	fovC = createDrawingCircle();
	Cam.FieldOfView = fovChangerOn and camFOV or gameDefFOV;
	toggleESP(espOn);
	updFOVCircle();
	updAllExclLblsVis();

    setupTool(findTool())

	local tapRayParams = RaycastParams.new(); tapRayParams.FilterType = Enum.RaycastFilterType.Blacklist; tapRayParams.IgnoreWater = true;
	local function tapExclude(input, gameProcessed) if gameProcessed then return end; if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then local unitRay = Cam:ScreenPointToRay(input.Position.X, input.Position.Y); tapRayParams.FilterDescendantsInstances = {char, Storage, MainGui}; local rayRes = workspace:Raycast(unitRay.Origin, unitRay.Direction * 500, tapRayParams); if rayRes and rayRes.Instance then local hitPart = rayRes.Instance; local hitC = hitPart:FindFirstAncestorWhichIsA("Model"); if hitC and hitC:FindFirstChildOfClass("Humanoid") then local targetPlr = P:GetPlayerFromCharacter(hitC); if targetPlr and targetPlr ~= plr then excludedPlrs[targetPlr] = not excludedPlrs[targetPlr]; updExclLbl(targetPlr);
            if espOn then local h = Storage:FindFirstChild(targetPlr.Name); if h and h:IsA("Highlight") then local origClr = h.FillColor; local feedbackClr = excludedPlrs[targetPlr] and THEME.Error or THEME.Success; h.FillColor = feedbackClr; h.FillTransparency = 0.3; task.delay(0.3, function() if h and h.Parent then h.FillColor = origClr; h.FillTransparency = 0.5; end end) end end; end end end end end; UIS.InputBegan:Connect(tapExclude);
	local function setupPlrListeners(p) if p == plr then return end; task.spawn(function() task.wait(0.1); if not p or not p.Parent then return end; if excludedPlrs[p] then updExclLbl(p) end; if espOn then applyHighlight(p) end; p.CharacterAdded:Connect(function(newC) task.wait(0.1); if not p or not p.Parent then return end; if excludedPlrs[p] then updExclLbl(p) end; if espOn then applyHighlight(p) end end); p.CharacterRemoving:Connect(function(oldC) local head = oldC and oldC:FindFirstChild("Head"); local existingLbl = head and head:FindFirstChild("ExcludeLabel"); if existingLbl then existingLbl:Destroy() end; local h = Storage:FindFirstChild(p.Name); if h then h.Adornee = nil end end) end) end; P.PlayerAdded:Connect(function(newPlr) if newPlr ~= plr then setupPlrListeners(newPlr) end end); P.PlayerRemoving:Connect(function(leavingPlr) excludedPlrs[leavingPlr] = nil; removeHighlight(leavingPlr); end); for _, existingPlr in pairs(P:GetPlayers()) do setupPlrListeners(existingPlr) end;

    plr.CharacterAdded:Connect(function(newC)
        char = newC;
        task.wait(0.2);
        backpack = plr:FindFirstChild("Backpack") or plr:WaitForChild("Backpack", 5);
        setupTool(findTool())
        for targetPlr, isExcl in pairs(excludedPlrs) do
            if isExcl then updExclLbl(targetPlr) end
        end
        newC.ChildAdded:Connect(function(child) if child:IsA("Tool") then setupTool(child) end end)
        newC.ChildRemoved:Connect(function(child) if child == currTool then setupTool(nil) end end)
    end)

    if char then
         char.ChildAdded:Connect(function(child) if child:IsA("Tool") then setupTool(child) end end)
         char.ChildRemoved:Connect(function(child) if child == currTool then setupTool(nil) end end)
    end

    plr.ChildAdded:Connect(function(child) if child.Name == "Backpack" and child:IsA("Backpack") then backpack = child end end);

	RuS.RenderStepped:Connect(function(dt)
        if not char or not char.Parent then
            char = plr.Character;
            if not char then return end
        end
        local equippedTool = nil
        if char then equippedTool = char:FindFirstChildOfClass("Tool") end
        if equippedTool ~= currTool then setupTool(equippedTool) end

        if currTool and not currTool.Enabled and currEffCD > 0 then
            if tick() - lastShot >= currEffCD then
                 pcall(function() currTool.Enabled = true end)
                 currEffCD = 0
            end
        end
        pcall(updFOVCircle);
        pcall(shoot)
    end);
end)

if not s then
    warn("THE MIST Triggerbot Module (Delay Switcher) failed to initialize:", e)
    if MainGui and MainGui.Parent then MainGui:Destroy() end; if Storage and Storage.Parent then Storage:Destroy() end; if fovC and fovC.Destroy then fovC:Destroy(); fovC = nil end; if actConn then actConn:Disconnect() end
end

if script and script:IsA("Script") then script.Destroying:Connect(function()
    if currTool and currTool.Parent and not currTool.Enabled then pcall(function() currTool.Enabled = true end) end
    if actConn then actConn:Disconnect(); actConn = nil end
    if MainGui and MainGui.Parent then MainGui:Destroy() end; if Storage and Storage.Parent then Storage:Destroy() end; if fovC and fovC.Destroy then fovC:Destroy(); fovC = nil end;
end) end
--- END OF MODIFIED SCRIPT v27 (23 - Delay Mode Switcher) ---